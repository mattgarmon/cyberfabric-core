# ADR: OAGW Storage Schema (Portable Baseline + Backend-Specific Enhancements)

- **Status**: Proposed
- **Date**: 2026-02-11
- **Deciders**: OAGW Team

## Context

OAGW persists configuration for upstreams, routes, and plugins. The gateway must evaluate this configuration on the proxy request hot path (upstream resolution, route matching, and effective-config merge across a tenant hierarchy), so the storage model must support efficient filtering/ordering, with a portable baseline and optional backend-specific optimizations.

This project supports multiple SQL backends via `modkit-db` (PostgreSQL, MySQL, SQLite). Therefore the storage model must be implementable on all supported backends with consistent behavior and security guarantees. A portable baseline is preferred, but backend-specific schema and SQL may be used when needed.

### Constraints

- A portable baseline schema is preferred, but physical schema definitions may diverge per backend when required.
- Queries must be tenant-scoped via the secure data access layer (parameter binding + tenant/resource scoping).
- The system must support tenant hierarchy behaviors (shadowing + inheritance/merge) across supported backends; implementations may use backend-specific SQL when needed.
- Foreign keys must reference OAGW-owned tables only; cross-module referential integrity is enforced in application code.

### Assumptions

- Writes are infrequent (configuration changes) while reads are frequent (evaluated for proxy requests).
- Tenant hierarchy depth is small (typically a few levels), so hierarchy ordering can be expressed as a derived table.
- UUIDs are generated by the application; storage may use a native `UUID` column type on PostgreSQL or `CHAR(36)` text on other backends.

### Scope / Non-goals

- In scope: persistent representation of upstreams, routes, plugins, and their bindings; portable query patterns for discovery and route selection.
- Non-goals for the baseline: relying on database-specific optimizations (e.g., `JSONB` operators, `GIN` indexes, partial indexes) for correctness, and cross-module foreign keys (e.g., to `tenant` or `principal`).
- This ADR includes baseline DDL and query examples to make the decision reviewable and actionable; implementations and migrations may diverge per backend while preserving the non-negotiable invariants.

### Stakeholders

- OAGW runtime (proxy request routing and policy enforcement)
- OAGW configuration APIs and operators managing gateway configuration
- Platform teams supporting different SQL backends via `modkit-db`

## Motivation

This schema defines the storage model for OAGW configuration across the **SQL backends supported by modkit-db** (PostgreSQL, MySQL, SQLite).

The goal is consistent behavior and security guarantees across backends. A portable baseline schema and query set is preferred, but backend-specific schema or SQL may be used when required for performance, operability, or backend compatibility.

Where backend-specific implementations exist, they must preserve the same domain semantics (tenant scoping, hierarchy resolution, route matching, and effective configuration merge) and must not change correctness or security guarantees.

## Design Principles

1. **Application-generated UUIDs** — UUIDs are generated by the application (no `gen_random_uuid()` defaults). Prefer a native `UUID` column type on PostgreSQL; use `CHAR(36)` text where a portable baseline is needed
2. **Hybrid column strategy** — hot-path scalars (sharing modes, match keys) are promoted to scalar columns (indexed where needed); opaque config blobs stay as `TEXT` JSON
3. **Join tables for multi-value data** — tags, plugin bindings, and route methods use proper join tables instead of JSON arrays, enabling DB-level filtering
4. **Backend portability, not uniformity** — prefer a shared baseline, but allow backend-specific types/functions (e.g., timestamp defaults, JSON types) when required, provided behavior stays consistent
5. **Index strategy** — use standard B-tree indexes as the baseline; backend-specific indexes (e.g., `GIN`, partial indexes) may be added to improve performance without changing query semantics
6. **ORM migrations** — migrations may branch per backend when required for compatibility or optimization, while preserving the same domain model and behavior
7. **Secure data access** — all queries are scoped by tenant via the secure data access layer; queries must (a) be correct and secure across supported backends, (b) use parameter binding, and (c) apply tenant/resource scoping
8. **Foreign keys reference OAGW tables only** — no cross-module FK references (`tenant`, `principal`); enforce referential integrity in application code

## Options

### Option 1: Portable baseline schema + optional backend-specific enhancements (Chosen)

Define a baseline schema and portable query patterns that work across all `modkit-db` backends, and allow backend-specific schema and SQL when needed for performance or compatibility.

Key properties:

- Baseline favors portable column types and standard B-tree indexes.
- Backend-specific enhancements are allowed (e.g., PostgreSQL `UUID`, `JSONB`, specialized indexes), but must not change correctness or security guarantees.
- Migrations may branch per backend while preserving the same domain semantics.

### Option 2: PostgreSQL-first schema with best-effort compatibility

Use PostgreSQL-native features throughout (e.g., `UUID` + default generators, `JSONB` with operators, `GIN` indexes, partial indexes) and implement other backends as reduced-capability variants.

This reduces early implementation effort for PostgreSQL, but increases long-term divergence risk and makes behavior parity harder to guarantee.

### Option 3: Fully normalized schema (no JSON blobs)

Model all configuration as fully relational tables with strong constraints and minimal opaque JSON.

This increases DB-level queryability and integrity constraints, but significantly increases schema complexity and migration/maintenance burden.

## Decision

Adopt **Option 1**: a portable baseline schema with portable query patterns, while permitting backend-specific schema and SQL when required.

The baseline must remain sufficient for correctness and security. Backend-specific enhancements are treated as optimizations and must preserve the same domain semantics (tenant scoping, hierarchy resolution, route matching, effective configuration merge).

Non-negotiable invariants:

- All reads and writes are tenant-scoped through the secure data access layer (parameter binding + tenant/resource scoping).
- Multi-table configuration updates are applied atomically so readers do not observe partially-applied state.
- Tenant hierarchy ordering and shadowing semantics are preserved (closest tenant wins for alias resolution; ancestors participate in effective configuration merge).
- Route matching uses an explicit discriminator (`match_type`) and typed match keys (HTTP match keys and gRPC match keys are stored/queried in typed structures, not inferred from opaque JSON).
- The match discriminator and typed match keys remain consistent: each route has exactly one match type and the corresponding match-key representation.
- Multi-value associations that affect selection/filtering (methods, tags, plugin bindings) are represented as joinable data (e.g., join tables or equivalent), not only embedded in opaque JSON.
- Plugin bindings preserve explicit ordering and per-binding configuration (ordering is stable and per-binding config is validated against the plugin's schema at write time).
- Backend-specific schema/SQL may improve performance or ergonomics, but must not change correctness/security guarantees or observable behavior.

## Security Considerations

- Tenant isolation is mandatory: configuration reads and writes must never cross tenant boundaries except where explicitly intended by tenant hierarchy semantics.
- No secrets are stored in this schema. Sensitive values must be referenced indirectly (e.g., `secret_ref`) and resolved via the project's secret management mechanism.
- `oagw_plugin.source_code` is treated as untrusted input. Custom plugin code must be validated at write time and executed only within a sandbox with explicit limits.
- The secure data access layer must guarantee parameter binding and consistent tenant/resource scoping for all queries, and must fail closed on missing/invalid security context.

## Entity Relationship

```text
┌────────────────────────┐
│      oagw_upstream     │
├────────────────────────┤
│ id (PK)                │
│ tenant_id              │
│ alias                  │
│ protocol               │
│ enabled                │
│ auth_sharing           │
│ rate_limit_sharing     │
│ plugins_sharing        │
│ server        (JSON)   │
│ auth_config   (JSON)   │
│ headers       (JSON)   │
│ cors          (JSON)   │
│ rate_limit    (JSON)   │
│ created_at             │
│ updated_at             │
└────────────────────────┘

┌────────────────────────────┐
│    oagw_upstream_tag       │
├────────────────────────────┤
│ upstream_id (PK, FK) ───────────▶ oagw_upstream.id
│ tag          (PK)          │
└────────────────────────────┘

┌────────────────────────────┐
│   oagw_upstream_plugin     │
├────────────────────────────┤
│ upstream_id (PK, FK) ───────────▶ oagw_upstream.id
│ position     (PK)          │
│ plugin_id    (FK) ──────────────▶ oagw_plugin.id
│ config       (JSON)        │
└────────────────────────────┘

┌────────────────────────┐
│        oagw_route      │
├────────────────────────┤
│ id (PK)                │
│ tenant_id              │
│ upstream_id (FK) ───────────▶ oagw_upstream.id
│ enabled                │
│ priority               │
│ rate_limit_sharing     │
│ plugins_sharing        │
│ match_type             │
│ match_config   (JSON)  │
│ cors           (JSON)  │
│ rate_limit     (JSON)  │
│ created_at             │
│ updated_at             │
└────────────────────────┘

┌────────────────────────────┐
│     oagw_route_method      │
├────────────────────────────┤
│ route_id (PK, FK) ─────────────▶ oagw_route.id
│ method   (PK)              │
└────────────────────────────┘

┌────────────────────────────┐
│     oagw_route_plugin      │
├────────────────────────────┤
│ route_id (PK, FK) ─────────────▶ oagw_route.id
│ position  (PK)             │
│ plugin_id (FK) ────────────────▶ oagw_plugin.id
│ config    (JSON)           │
└────────────────────────────┘

┌────────────────────────────┐
│      oagw_route_tag        │
├────────────────────────────┤
│ route_id (PK, FK) ─────────────▶ oagw_route.id
│ tag       (PK)             │
└────────────────────────────┘

┌────────────────────────────┐
│   oagw_route_http_match    │
├────────────────────────────┤
│ route_id (PK, FK) ─────────────▶ oagw_route.id
│ path_prefix                │
└────────────────────────────┘

┌────────────────────────────┐
│   oagw_route_grpc_match    │
├────────────────────────────┤
│ route_id (PK, FK) ─────────────▶ oagw_route.id
│ service                    │
│ method                     │
└────────────────────────────┘

┌────────────────────────┐
│      oagw_plugin       │
├────────────────────────┤
│ id (PK)                │
│ tenant_id              │
│ builtin                │
│ name                   │
│ description            │
│ plugin_type            │
│ phases                 │
│ config_schema (JSON)   │
│ source_code (nullable) │
│ last_used_at           │
│ gc_eligible_at         │
│ created_at             │
│ updated_at             │
└────────────────────────┘
```

**Table count**: 3 core tables + 7 support tables = 10 total.

## Table Definitions

The DDL below describes the **portable baseline** schema. It is expressed as cross-database-compatible SQL where possible.

Backends may use tailored DDL and types (e.g., PostgreSQL `UUID`/`JSONB`, backend-specific defaults or indexes) as long as the domain model and the non-negotiable invariants in this ADR are preserved.

The ORM migration layer translates these definitions into the appropriate dialect for each supported backend.

Migration creation order (baseline):

1. `oagw_plugin`
2. `oagw_upstream`
3. `oagw_upstream_tag`
4. `oagw_upstream_plugin`
5. `oagw_route`
6. `oagw_route_http_match`
7. `oagw_route_grpc_match`
8. `oagw_route_method`
9. `oagw_route_tag`
10. `oagw_route_plugin`

---

### oagw_upstream

Stores upstream service definitions. One row per (tenant, alias) pair.

Sharing modes are promoted to scalar columns so hierarchy merge queries can filter at the DB level without parsing JSON.

Protocol representation: `oagw_upstream.protocol` stores a short discriminator (`http` or `grpc`) and is validated by the database `CHECK` constraint. The Management API uses canonical GTS protocol identifiers (e.g., `gts.x.core.oagw.protocol.v1~x.core.http.v1`, `gts.x.core.oagw.protocol.v1~x.core.grpc.v1`). The request/response boundary that maps API payloads to DB models must transform between these representations:

- API `gts.x.core.oagw.protocol.v1~x.core.http.v1` ↔ DB `http`
- API `gts.x.core.oagw.protocol.v1~x.core.grpc.v1` ↔ DB `grpc`

```sql
CREATE TABLE IF NOT EXISTS oagw_upstream (
    id                  CHAR(36)     PRIMARY KEY,
    tenant_id           CHAR(36)     NOT NULL,
    alias               VARCHAR(255) NOT NULL,
    protocol            VARCHAR(100) NOT NULL,
    enabled             BOOLEAN      NOT NULL DEFAULT TRUE,
    auth_sharing        VARCHAR(10)  NOT NULL DEFAULT 'private',
    rate_limit_sharing  VARCHAR(10)  NOT NULL DEFAULT 'private',
    plugins_sharing     VARCHAR(10)  NOT NULL DEFAULT 'private',
    server              TEXT         NOT NULL,
    auth_config         TEXT,
    headers             TEXT,
    cors                TEXT,
    rate_limit          TEXT,
    created_at          TEXT         NOT NULL,
    updated_at          TEXT         NOT NULL,
    CHECK (protocol IN ('http', 'grpc'))
);

CREATE UNIQUE INDEX uq_upstream_tenant_alias ON oagw_upstream (tenant_id, alias);
CREATE INDEX idx_upstream_alias ON oagw_upstream (alias);
```

---

### oagw_upstream_tag

Join table for upstream tags. Enables DB-level tag filtering via `JOIN` / `EXISTS`.

```sql
CREATE TABLE IF NOT EXISTS oagw_upstream_tag (
    upstream_id  CHAR(36)     NOT NULL REFERENCES oagw_upstream(id) ON DELETE CASCADE,
    tag          VARCHAR(100) NOT NULL,
    PRIMARY KEY (upstream_id, tag)
);

CREATE INDEX idx_upstream_tag_tag_upstream ON oagw_upstream_tag (tag, upstream_id);
```

---

### oagw_upstream_plugin

Join table for plugin bindings on upstreams. Both builtin and custom plugins are stored here, referenced by `plugin_id` (`CHAR(36)`) with FK to `oagw_plugin.id`. PK is `(upstream_id, position)` — this enforces unique ordering and allows the same plugin to appear at multiple positions with different `config` (e.g., a transform plugin at position 0 and position 3 with different parameters). `config` holds per-binding configuration as a JSON `TEXT` blob, validated against the plugin's `config_schema` at write time.

```sql
CREATE TABLE IF NOT EXISTS oagw_upstream_plugin (
    upstream_id  CHAR(36)     NOT NULL REFERENCES oagw_upstream(id) ON DELETE CASCADE,
    position     INTEGER      NOT NULL,
    plugin_id    CHAR(36)     NOT NULL REFERENCES oagw_plugin(id) ON DELETE RESTRICT,
    config       TEXT,
    PRIMARY KEY (upstream_id, position)
);

CREATE INDEX idx_upstream_plugin_plugin_upstream ON oagw_upstream_plugin (plugin_id, upstream_id);
```

---

### oagw_route

Stores route definitions. Each route belongs to one upstream.

Protocol-specific match keys live in typed match tables (`oagw_route_http_match`, `oagw_route_grpc_match`). The full match config (query_allowlist, path_suffix_mode, optional gRPC metadata) stays in `match_config` JSON.

```sql
CREATE TABLE IF NOT EXISTS oagw_route (
    id                  CHAR(36)      PRIMARY KEY,
    tenant_id           CHAR(36)      NOT NULL,
    upstream_id         CHAR(36)      NOT NULL REFERENCES oagw_upstream(id) ON DELETE CASCADE,
    enabled             BOOLEAN       NOT NULL DEFAULT TRUE,
    priority            INTEGER       NOT NULL DEFAULT 0,
    rate_limit_sharing  VARCHAR(10)   NOT NULL DEFAULT 'private',
    plugins_sharing     VARCHAR(10)   NOT NULL DEFAULT 'private',
    match_type          VARCHAR(10)   NOT NULL,
    match_config        TEXT,
    cors                TEXT,
    rate_limit          TEXT,
    created_at          TEXT          NOT NULL,
    updated_at          TEXT          NOT NULL,
    CHECK (match_type IN ('http', 'grpc'))
);

CREATE INDEX idx_route_tenant ON oagw_route (tenant_id);
CREATE INDEX idx_route_upstream_enabled_match_priority ON oagw_route (upstream_id, enabled, match_type, priority);
```

---

### oagw_route_http_match

Stores HTTP match keys for a route. `path_prefix` is used for longest-prefix route selection.

```sql
CREATE TABLE IF NOT EXISTS oagw_route_http_match (
    route_id     CHAR(36)      NOT NULL REFERENCES oagw_route(id) ON DELETE CASCADE,
    path_prefix  VARCHAR(2048) NOT NULL,
    PRIMARY KEY (route_id)
);

CREATE INDEX idx_route_http_match_path_prefix_route ON oagw_route_http_match (path_prefix, route_id);
```

---

### oagw_route_grpc_match

Stores gRPC match keys for a route. gRPC routes match by `(service, method)`.

```sql
CREATE TABLE IF NOT EXISTS oagw_route_grpc_match (
    route_id   CHAR(36)     NOT NULL REFERENCES oagw_route(id) ON DELETE CASCADE,
    service    VARCHAR(255) NOT NULL,
    method     VARCHAR(255) NOT NULL,
    PRIMARY KEY (route_id)
);

CREATE INDEX idx_route_grpc_match_service_method_route ON oagw_route_grpc_match (service, method, route_id);
```

---

### oagw_route_method

Join table for HTTP methods a route matches. Enables DB-level method filtering.

```sql
CREATE TABLE IF NOT EXISTS oagw_route_method (
    route_id   CHAR(36)    NOT NULL REFERENCES oagw_route(id) ON DELETE CASCADE,
    method     VARCHAR(10) NOT NULL,
    PRIMARY KEY (route_id, method)
);

CREATE INDEX idx_route_method_method_route ON oagw_route_method (method, route_id);
```

---

### oagw_route_plugin

Join table for plugin bindings on routes. Same pattern as `oagw_upstream_plugin`: PK `(route_id, position)`, allowing the same plugin at multiple positions with different `config`.

```sql
CREATE TABLE IF NOT EXISTS oagw_route_plugin (
    route_id    CHAR(36)     NOT NULL REFERENCES oagw_route(id) ON DELETE CASCADE,
    position    INTEGER      NOT NULL,
    plugin_id   CHAR(36)     NOT NULL REFERENCES oagw_plugin(id) ON DELETE RESTRICT,
    config      TEXT,
    PRIMARY KEY (route_id, position)
);

CREATE INDEX idx_route_plugin_plugin_route ON oagw_route_plugin (plugin_id, route_id);
```

---

### oagw_route_tag

Join table for route tags.

```sql
CREATE TABLE IF NOT EXISTS oagw_route_tag (
    route_id   CHAR(36)     NOT NULL REFERENCES oagw_route(id) ON DELETE CASCADE,
    tag        VARCHAR(100) NOT NULL,
    PRIMARY KEY (route_id, tag)
);

CREATE INDEX idx_route_tag_tag_route ON oagw_route_tag (tag, route_id);
```

---

### oagw_plugin

Stores all plugin definitions — both **builtin** (system-provided, seeded on startup/migration) and **custom** (tenant-defined Starlark). The `builtin` flag distinguishes them: builtin plugins have `builtin = true`, deterministic UUIDs, `source_code = NULL`, and a system tenant. Custom plugins have `builtin = false` and contain Starlark source code.

ORM scoping note: the secure ORM layer applies tenant isolation as `tenant_id IN scope.tenant_ids`. To allow uniform UUID-based references from join tables to resolve builtin plugins, plugin read scopes must include the reserved system tenant ID (`SYSTEM_TENANT_ID`, non-nil) in addition to the request tenant hierarchy.

```sql
CREATE TABLE IF NOT EXISTS oagw_plugin (
    id              CHAR(36)     PRIMARY KEY,
    tenant_id       CHAR(36)     NOT NULL,
    builtin         BOOLEAN      NOT NULL DEFAULT FALSE,
    name            VARCHAR(255) NOT NULL,
    description     TEXT,
    plugin_type     VARCHAR(20)  NOT NULL,
    phases          VARCHAR(100) NOT NULL,
    config_schema   TEXT         NOT NULL,
    source_code     TEXT,          -- NULL for builtin plugins
    last_used_at    TEXT,
    gc_eligible_at  TEXT,
    created_at      TEXT         NOT NULL,
    updated_at      TEXT         NOT NULL
);

CREATE UNIQUE INDEX uq_plugin_tenant_name ON oagw_plugin (tenant_id, name);
CREATE INDEX idx_plugin_type ON oagw_plugin (plugin_type);
CREATE INDEX idx_plugin_gc ON oagw_plugin (gc_eligible_at);
```

## JSON Column Schemas

In the **baseline** schema, opaque configuration blobs are stored as JSON `TEXT`. Backends may use equivalent JSON-capable types while preserving the non-negotiable invariants in this ADR. The application layer (Rust structs with `serde`) is the single source of truth for structure.

### upstream.server

```json
{
  "endpoints": [
    { "scheme": "https", "host": "api.openai.com", "port": 443 }
  ]
}
```

### upstream.auth_config

The sharing mode is in the `auth_sharing` scalar column. This blob holds the auth plugin UUID (referencing `oagw_plugin.id`) and per-upstream config.

```json
{
  "plugin_id": "a1b2c3d4-0000-5000-8000-000000000002",
  "config": {
    "header": "Authorization",
    "prefix": "Bearer ",
    "secret_ref": "cred://partner-openai-key"
  }
}
```

### upstream.headers

```json
{
  "request": {
    "set": { "X-Custom": "value" },
    "add": {},
    "remove": ["X-Internal"],
    "passthrough": "none",
    "passthrough_allowlist": []
  },
  "response": {
    "set": {},
    "add": {},
    "remove": []
  }
}
```

### upstream.cors / route.cors

CORS configuration for browser clients. Can be set at upstream level (applies to all routes) or route level (overrides upstream).

```json
{
  "enabled": true,
  "allowed_origins": ["https://app.example.com"],
  "allowed_methods": ["GET", "POST"],
  "allowed_headers": ["Content-Type", "Authorization"],
  "max_age": 3600,
  "allow_credentials": true
}
```

### upstream.rate_limit / route.rate_limit

The sharing mode is in the `rate_limit_sharing` scalar column. This blob holds the rate limit parameters only.

```json
{
  "algorithm": "token_bucket",
  "sustained": { "rate": 10000, "window": "minute" },
  "burst": { "capacity": 15000 },
  "scope": "tenant",
  "strategy": "reject",
  "response_headers": true,
  "budget": {
    "mode": "allocated",
    "total": 100000,
    "overcommit_ratio": 1.0
  }
}
```

### route.match_config

Extended match configuration beyond the match keys and methods.

For HTTP routes:

```json
{
  "query_allowlist": ["version"],
  "path_suffix_mode": "append"
}
```

For gRPC routes (match keys stored in `oagw_route_grpc_match`):

```json
{
  "grpc": {
    "metadata_allowlist": ["x-tenant", "x-request-id"]
  }
}
```

### plugin.config_schema

Standard JSON Schema object, stored as text.

### upstream_plugin.config / route_plugin.config

Per-binding plugin configuration. This JSON blob is validated against the referenced plugin's `config_schema` at write time. Allows the same plugin definition to be reused across multiple upstreams/routes with different runtime parameters.

Example — a guard plugin with per-binding thresholds:

```json
{
  "max_body_size": 1048576,
  "required_headers": ["X-Api-Key", "X-Tenant-Id"]
}
```

Example — a transform plugin with per-binding field list:

```json
{
  "redact_fields": ["$.user.email", "$.user.phone"],
  "placeholder": "[REDACTED]"
}
```

If `config` is `null`, the plugin uses its `config_schema` defaults. Builtin plugins that require no configuration may omit this field.

## Query Patterns

All queries are scoped by tenant via the secure data access layer. The examples below use cross-database-compatible constructs where possible and push as much logic as possible into SQL (ordering, filtering, dedup). Backend-specific variants may be used when required, as long as they preserve the non-negotiable invariants.

**Hierarchy convention** — queries that need tenant hierarchy ordering use a derived table `h(tid, depth)` built from `UNION ALL SELECT` (portable across PostgreSQL, MySQL, SQLite). The ORM generates this dynamically based on the resolved hierarchy. `depth 0` = requesting tenant (closest), `depth 1` = parent, etc. Example for a 3-level hierarchy:

```sql
-- Derived hierarchy table (generated by ORM, depth 0 = closest)
(SELECT :t0 AS tid, 0 AS depth
 UNION ALL SELECT :t1, 1
 UNION ALL SELECT :t2, 2) h
```

### Find Upstream by Alias (Proxy Hot Path)

Resolves an upstream for a proxy request. Joins the hierarchy table to filter and order by depth in one step.

```sql
SELECT u.* FROM oagw_upstream u
JOIN (SELECT :t0 AS tid, 0 AS depth
      UNION ALL SELECT :t1, 1
      UNION ALL SELECT :t2, 2) h ON h.tid = u.tenant_id
WHERE u.alias = :alias
ORDER BY h.depth ASC;
```

**Application processing** — the result set is already sorted closest-first. The app takes the first row as the resolved upstream, but must still check ancestor rows: if any ancestor has `enabled = false`, the upstream is blocked.

```text
function resolve_closest(rows):
    if any row has enabled = false:
        return None  -- ancestor disabled, block access
    return first(rows)
```

### Discover Upstreams by Tag (DB-Level Filtering)

Uses the `oagw_upstream_tag` join table to filter at the DB level — no JSON parsing needed.

```sql
-- Find upstreams that have ALL of the specified tags (AND semantics)
SELECT u.* FROM oagw_upstream u
WHERE u.tenant_id IN (:tenant_hierarchy)
  -- For each required tag, add an EXISTS clause:
  AND EXISTS (
      SELECT 1 FROM oagw_upstream_tag t
      WHERE t.upstream_id = u.id AND t.tag = :tag_1
  )
  AND EXISTS (
      SELECT 1 FROM oagw_upstream_tag t
      WHERE t.upstream_id = u.id AND t.tag = :tag_2
  );
  -- ... repeat for each tag
```

### Find Matching HTTP Route for Request (DB-Level Method + Path Filtering)

Uses `oagw_route_method` join table and `oagw_route_http_match.path_prefix` to narrow candidates at the DB level. The prefix test is expressed using `SUBSTR()` + `LENGTH()` to avoid backend-specific string concatenation operators.

```sql
SELECT r.*, hm.path_prefix FROM oagw_route r
JOIN oagw_route_http_match hm ON hm.route_id = r.id
WHERE r.upstream_id = :upstream_id
  AND r.enabled = TRUE
  AND r.match_type = 'http'
  AND SUBSTR(:request_path, 1, LENGTH(hm.path_prefix)) = hm.path_prefix
  AND EXISTS (
      SELECT 1 FROM oagw_route_method m
      WHERE m.route_id = r.id AND m.method = :http_method
  )
ORDER BY LENGTH(hm.path_prefix) DESC, r.priority DESC
LIMIT 1;
```

The query returns the single best-matching route row plus the matched `path_prefix` — longest prefix match wins, with `priority` as tiebreaker.

### Find Matching gRPC Route for Request (DB-Level Service + Method Filtering)

Routes gRPC by matching on `(service, method)`.

```sql
SELECT r.*, gm.service, gm.method FROM oagw_route r
JOIN oagw_route_grpc_match gm ON gm.route_id = r.id
WHERE r.upstream_id = :upstream_id
  AND r.enabled = TRUE
  AND r.match_type = 'grpc'
  AND gm.service = :grpc_service
  AND gm.method = :grpc_method
ORDER BY r.priority DESC
LIMIT 1;
```

The query returns the single best-matching route row plus the matched `(service, method)` keys, with `priority` as tiebreaker.

### List Upstreams for Tenant (with Shadowing)

Uses a correlated subquery with the hierarchy table to pick the closest tenant per alias — shadowing is resolved entirely in SQL.

```sql
SELECT u.* FROM oagw_upstream u
JOIN (SELECT :t0 AS tid, 0 AS depth
      UNION ALL SELECT :t1, 1
      UNION ALL SELECT :t2, 2) h ON h.tid = u.tenant_id
WHERE u.id = (
    SELECT s.id FROM oagw_upstream s
    JOIN (SELECT :t0 AS tid, 0 AS depth
          UNION ALL SELECT :t1, 1
          UNION ALL SELECT :t2, 2) h2 ON h2.tid = s.tenant_id
    WHERE s.alias = u.alias
    ORDER BY h2.depth ASC
    LIMIT 1
)
ORDER BY u.alias ASC;
```

Each alias appears at most once — the closest tenant in the hierarchy wins. No application-level dedup needed.

### Resolve Effective Configuration (Hierarchy Merge)

Sharing modes are scalar columns — the merge logic can inspect them without JSON parsing. The upstream query returns the target upstream plus all ancestors with the same alias, ordered by hierarchy depth. A separate route query returns the route plus its match discriminator and protocol match keys.

```sql
SELECT u.* FROM oagw_upstream u
JOIN (SELECT :t0 AS tid, 0 AS depth
      UNION ALL SELECT :t1, 1
      UNION ALL SELECT :t2, 2) h ON h.tid = u.tenant_id
WHERE u.alias = :upstream_alias
ORDER BY h.depth ASC;

SELECT r.*, r.match_type, hm.path_prefix, gm.service, gm.method
FROM oagw_route r
LEFT JOIN oagw_route_http_match hm ON hm.route_id = r.id
LEFT JOIN oagw_route_grpc_match gm ON gm.route_id = r.id
WHERE r.id = :route_id;
```

**Application processing** — upstream rows are already sorted closest-first. The app merges configs using the scalar sharing columns (`auth_sharing`, `rate_limit_sharing`, `plugins_sharing`) to decide whether a descendant may override, must inherit, or is blocked by an enforced ancestor. JSON blobs are parsed only when applying the effective configuration (auth/rate limit/plugin settings) after the merge strategy is determined.

### Plugin Usage Tracking (DB-Level via Join Tables)

With join tables storing direct UUID references (`plugin_id` → `oagw_plugin.id`), GC eligibility updates are bulk SQL — no per-row application loop needed. Builtin plugins are excluded from GC.

Note: plugin references embedded in JSON blobs (e.g., `upstream.auth_config.plugin_id`) are not visible to SQL unless the application extracts them into join-table rows or otherwise updates usage.

```sql
-- Mark referenced custom plugins as in-use (clear GC, update last_used_at)
UPDATE oagw_plugin
SET gc_eligible_at = NULL, last_used_at = :now
WHERE builtin = FALSE
  AND tenant_id IN (:tenant_hierarchy)
  AND gc_eligible_at IS NOT NULL
  AND id IN (
      SELECT up.plugin_id FROM oagw_upstream_plugin up
      JOIN oagw_upstream u ON u.id = up.upstream_id
      WHERE u.tenant_id IN (:tenant_hierarchy)
      UNION
      SELECT rp.plugin_id FROM oagw_route_plugin rp
      JOIN oagw_route r ON r.id = rp.route_id
      WHERE r.tenant_id IN (:tenant_hierarchy)
  );

-- Mark unreferenced custom plugins as GC-eligible
UPDATE oagw_plugin
SET gc_eligible_at = :gc_at
WHERE builtin = FALSE
  AND tenant_id IN (:tenant_hierarchy)
  AND gc_eligible_at IS NULL
  AND id NOT IN (
      SELECT up.plugin_id FROM oagw_upstream_plugin up
      JOIN oagw_upstream u ON u.id = up.upstream_id
      WHERE u.tenant_id IN (:tenant_hierarchy)
      UNION
      SELECT rp.plugin_id FROM oagw_route_plugin rp
      JOIN oagw_route r ON r.id = rp.route_id
      WHERE r.tenant_id IN (:tenant_hierarchy)
  );
```

No application processing needed — both updates run as single statements.

### Delete Garbage-Collected Plugins

```sql
-- Delete custom plugins past their GC eligibility date
-- Builtin plugins are never GC'd (filtered out as a safety guard)
DELETE FROM oagw_plugin
WHERE builtin = FALSE
  AND gc_eligible_at IS NOT NULL
  AND gc_eligible_at < :now
  AND tenant_id IN (:tenant_hierarchy);
```

Single statement — no application loop needed. The ORM returns the count of deleted rows.

### List Routes by Upstream

Lists enabled routes for an upstream and returns match keys via joins to the match tables.

```sql
SELECT r.*, r.match_type, hm.path_prefix, gm.service, gm.method
FROM oagw_route r
LEFT JOIN oagw_route_http_match hm ON hm.route_id = r.id
LEFT JOIN oagw_route_grpc_match gm ON gm.route_id = r.id
WHERE r.upstream_id = :upstream_id
  AND r.enabled = TRUE
ORDER BY r.priority DESC, r.created_at ASC
LIMIT :limit OFFSET :offset;
```

## Deferred Features

The following features are **future-facing** and are intentionally excluded from this schema:

- **Concurrency limiting + backpressure queueing** — Will require `concurrency_limit` JSON column on `oagw_upstream` and/or `oagw_route` when implemented.
- **Circuit breaker** — Will require `circuit_breaker` JSON column on `oagw_upstream` when implemented.

These will be added as new nullable `TEXT` JSON columns in a future migration, following the same pattern as `cors` and `rate_limit`.
